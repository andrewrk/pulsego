diff -r b51fd2d6c160 src/cmd/cgo/ast.go
--- a/src/cmd/cgo/ast.go	Tue Nov 10 20:05:24 2009 -0800
+++ b/src/cmd/cgo/ast.go	Fri Nov 20 15:48:01 2009 +0900
@@ -35,6 +35,7 @@
 	Typedef		map[string]ast.Expr;
 	Vardef		map[string]*Type;
 	Funcdef		map[string]*FuncType;
+	Enumdef		map[string]int64;
 	PtrSize		int64;
 	GccOptions	[]string;
 }
@@ -45,6 +46,7 @@
 	Align	int64;
 	C	string;
 	Go	ast.Expr;
+	EnumValues map[string]int64;
 }
 
 // A FuncType collects information about a function type in both the C and Go worlds.
diff -r b51fd2d6c160 src/cmd/cgo/gcc.go
--- a/src/cmd/cgo/gcc.go	Tue Nov 10 20:05:24 2009 -0800
+++ b/src/cmd/cgo/gcc.go	Fri Nov 20 15:48:01 2009 +0900
@@ -116,6 +116,7 @@
 
 	// Scan DWARF info for top-level TagVariable entries with AttrName __cgo__i.
 	types := make([]dwarf.Type, len(names));
+	enums := make([]dwarf.Offset, len(names));
 	r := d.Reader();
 	for {
 		e, err := r.Next();
@@ -125,8 +126,29 @@
 		if e == nil {
 			break
 		}
-		if e.Tag != dwarf.TagVariable {
+		switch e.Tag {
+		default:
 			goto Continue
+		case dwarf.TagEnumerationType:
+			offset := e.Offset;
+			for {
+				e, err := r.Next();
+				if err != nil {
+					fatal("reading DWARF entry: %s", err)
+				}
+				if e.Tag == 0 {
+					break
+				}
+				if e.Tag == dwarf.TagEnumerator {
+					entryName := e.Val(dwarf.AttrName).(string);
+					i, ok := m[entryName];
+					if ok {
+						enums[i] = offset
+					}
+				}
+			}
+			goto Continue;
+		case dwarf.TagVariable:
 		}
 		name, _ := e.Val(dwarf.AttrName).(string);
 		typOff, _ := e.Val(dwarf.AttrType).(dwarf.Offset);
@@ -148,7 +170,15 @@
 		if err != nil {
 			fatal("malformed __cgo__ name: %s", name)
 		}
-		types[i] = t.Type;
+		if enums[i] != 0 {
+			t, err := d.Type(enums[i]);
+			if err != nil {
+				fatal("loading DWARF type: %s", err)
+			}
+			types[i] = t
+		} else {
+			types[i] = t.Type
+		}
 
 	Continue:
 		if e.Tag != dwarf.TagCompileUnit {
@@ -311,6 +341,7 @@
 	t.Size = dtype.Size();
 	t.Align = -1;
 	t.C = dtype.Common().Name;
+	t.EnumValues = nil;
 	if t.Size < 0 {
 		fatal("dwarf.Type %s reports unknown size", dtype)
 	}
@@ -366,6 +397,10 @@
 			t.Align = c.ptrSize
 		}
 		t.C = "enum " + dt.EnumName;
+		t.EnumValues = make(map[string]int64);
+		for _, ev := range dt.Val {
+			t.EnumValues[ev.Name] = ev.Val
+		}
 
 	case *dwarf.FloatType:
 		switch t.Size {
diff -r b51fd2d6c160 src/cmd/cgo/main.go
--- a/src/cmd/cgo/main.go	Tue Nov 10 20:05:24 2009 -0800
+++ b/src/cmd/cgo/main.go	Fri Nov 20 15:48:01 2009 +0900
@@ -66,6 +66,7 @@
 	p.loadDebugInfo();
 	p.Vardef = make(map[string]*Type);
 	p.Funcdef = make(map[string]*FuncType);
+	p.Enumdef = make(map[string]int64);
 
 	for _, cref := range p.Crefs {
 		switch cref.Context {
@@ -83,8 +84,13 @@
 			}
 			// Reference to C variable.
 			// We declare a pointer and arrange to have it filled in.
-			*cref.Expr = &ast.StarExpr{X: &ast.Ident{Value: "_C_" + cref.Name}};
-			p.Vardef[cref.Name] = cref.Type;
+			if cref.Type.EnumValues == nil {
+				*cref.Expr = &ast.StarExpr{X: &ast.Ident{Value: "_C_" + cref.Name}};
+				p.Vardef[cref.Name] = cref.Type;
+			} else {
+				*cref.Expr = &ast.Ident{Value: cref.Name};
+				p.Enumdef[cref.Name] = cref.Type.EnumValues[cref.Name];
+			}
 		case "type":
 			if !cref.TypeName {
 				error((*cref.Expr).Pos(), "expression C.%s used as type", cref.Name)
diff -r b51fd2d6c160 src/cmd/cgo/out.go
--- a/src/cmd/cgo/out.go	Tue Nov 10 20:05:24 2009 -0800
+++ b/src/cmd/cgo/out.go	Fri Nov 20 15:48:01 2009 +0900
@@ -69,6 +69,11 @@
 	}
 	fmt.Fprintf(fc, "\n");
 
+	for name, value := range p.Enumdef {
+		fmt.Fprintf(fgo2, "const %s = %d\n", name, value)
+	}
+	fmt.Fprintf(fgo2, "\n");
+
 	for name, def := range p.Funcdef {
 		// Go func declaration.
 		d := &ast.FuncDecl{
